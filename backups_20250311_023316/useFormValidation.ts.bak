import { useState, useCallback } from 'react';

// Chinese comment replaced with English comment
type ValidationRule<T> = {
  validator: (value: T, formValues?: Record<string, any>) => boolean;
  message: string;
};

// Chinese comment replaced with English comment
type ValidationSchema<T> = {
  [K in keyof T]?: ValidationRule<T[K]>[];
};

// Chinese comment replaced with English comment
type Errors<T> = {
  [K in keyof T]?: string;
};

// Chinese comment replaced with English comment
type Touched<T> = {
  [K in keyof T]?: boolean;
};

// Chinese comment replaced with English comment
interface FormValidation<T> {
  values: T;
  errors: Errors<T>;
  touched: Touched<T>;
  isValid: boolean;
  handleChange: (field: keyof T, value: any) => void;
  handleBlur: (field: keyof T) => void;
  reset: () => void;
  setValues: (values: Partial<T>) => void;
  validateField: (field: keyof T) => boolean;
  validateForm: () => boolean;
}

/**
 * 表单验证钩子
 * @param initialValues 表单初始值
 * @param validationSchema 验证规则
 * @returns 表单状态和处理函数
 */
function useFormValidation<T extends Record<string, any>>(
  initialValues: T,
  validationSchema: ValidationSchema<T>
): FormValidation<T> {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Errors<T>>({});
  const [touched, setTouched] = useState<Touched<T>>({});

  // Chinese comment replaced with English comment
  const validateField = useCallback(
    (field: keyof T): boolean => {
      const fieldRules = validationSchema[field];
      if (!fieldRules) return true;

      for (const rule of fieldRules) {
        const isValid = rule.validator(values[field], values);
        if (!isValid) {
          setErrors((prev) => ({ ...prev, [field]: rule.message }));
          return false;
        }
      }

      // Chinese comment replaced with English comment
      setErrors((prev) => {
        const newErrors = { ...prev };
        delete newErrors[field as string];
        return newErrors;
      });
      return true;
    },
    [values, validationSchema]
  );

  // Chinese comment replaced with English comment
  const validateForm = useCallback((): boolean => {
    let isFormValid = true;
    const validatedFields = Object.keys(validationSchema) as Array<keyof T>;

    // Chinese comment replaced with English comment
    const allTouched = validatedFields.reduce(
      (acc, field) => ({ ...acc, [field]: true }),
      {} as Touched<T>
    );
    setTouched(allTouched);

    // Chinese comment replaced with English comment
    for (const field of validatedFields) {
      const fieldValid = validateField(field);
      if (!fieldValid) {
        isFormValid = false;
      }
    }

    return isFormValid;
  }, [validateField, validationSchema]);

  // Chinese comment replaced with English comment
  const handleChange = useCallback(
    (field: keyof T, value: any) => {
      setValues((prev) => ({ ...prev, [field]: value }));

      // Chinese comment replaced with English comment
      if (touched[field]) {
        validateField(field);
      }
    },
    [touched, validateField]
  );

  // Chinese comment replaced with English comment
  const handleBlur = useCallback(
    (field: keyof T) => {
      setTouched((prev) => ({ ...prev, [field]: true }));
      validateField(field);
    },
    [validateField]
  );

  // Chinese comment replaced with English comment
  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
  }, [initialValues]);

  // Chinese comment replaced with English comment
  const setFormValues = useCallback(
    (newValues: Partial<T>) => {
      setValues((prev) => ({ ...prev, ...newValues }));

      // Chinese comment replaced with English comment
      Object.keys(newValues).forEach((key) => {
        if (touched[key as keyof T]) {
          validateField(key as keyof T);
        }
      });
    },
    [touched, validateField]
  );

  // Chinese comment replaced with English comment
  const isFormValid = Object.keys(errors).length === 0;

  return {
    values,
    errors,
    touched,
    isValid: isFormValid,
    handleChange,
    handleBlur,
    reset,
    setValues: setFormValues,
    validateField,
    validateForm,
  };
}

// Chinese comment replaced with English comment
export const validators = {
  required: (value: any) => !!value || (typeof value === 'string' && value.trim() !== ''),
  email: (value: string) =>
    !value || /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(value),
  minLength: (min: number) => (value: string) => !value || value.length >= min,
  maxLength: (max: number) => (value: string) => !value || value.length <= max,
  numeric: (value: string) => !value || /^[0-9]+$/.test(value),
  decimal: (value: string) => !value || /^[0-9]+(\.[0-9]+)?$/.test(value),
  match: (fieldName: string, message?: string) => (value: any, formValues?: Record<string, any>) =>
    !value || !formValues || value === formValues[fieldName],
  url: (value: string) =>
    !value || /^(https?|ftp):\/\/[^\s/$.?#].[^\s]*$/i.test(value),
  walletAddress: (value: string) =>
    !value || /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(value),
};

export default useFormValidation; 