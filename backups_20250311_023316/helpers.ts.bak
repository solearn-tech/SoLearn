/**
 * SoLearn 实用工具函数库
 * 包含格式化、数据处理、验证等常用函数
 */

// Chinese comment replaced with English comment
export const formatDate = (date: Date | string | number): string => {
  const d = new Date(date);
  return d.toLocaleDateString('zh-CN', {
    year: 'numeric',
    month: 'long', 
    day: 'numeric'
  });
};

export const formatDateTime = (date: Date | string | number): string => {
  const d = new Date(date);
  return d.toLocaleDateString('zh-CN', {
    year: 'numeric',
    month: 'long', 
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
};

export const formatRelativeTime = (date: Date | string | number): string => {
  const d = new Date(date);
  const now = new Date();
  const diffInSeconds = Math.floor((now.getTime() - d.getTime()) / 1000);
  
  if (diffInSeconds < 60) {
    return `${diffInSeconds}seconds ago`;
  }
  
  const diffInMinutes = Math.floor(diffInSeconds / 60);
  if (diffInMinutes < 60) {
    return `${diffInMinutes}minutes ago`;
  }
  
  const diffInHours = Math.floor(diffInMinutes / 60);
  if (diffInHours < 24) {
    return `${diffInHours}hours ago`;
  }
  
  const diffInDays = Math.floor(diffInHours / 24);
  if (diffInDays < 30) {
    return `${diffInDays}days ago`;
  }
  
  const diffInMonths = Math.floor(diffInDays / 30);
  if (diffInMonths < 12) {
    return `${diffInMonths}months ago`;
  }
  
  const diffInYears = Math.floor(diffInMonths / 12);
  return `${diffInYears}years ago`;
};

// Chinese comment replaced with English comment
export const formatDuration = (minutes: number): string => {
  const hours = Math.floor(minutes / 60);
  const mins = minutes % 60;
  
  if (hours === 0) {
    return `${mins}分钟`;
  }
  
  return `${hours}小时${mins > 0 ? ` ${mins}分钟` : ''}`;
};

// Chinese comment replaced with English comment
export const formatNumber = (num: number, options?: Intl.NumberFormatOptions): string => {
  return new Intl.NumberFormat('zh-CN', options).format(num);
};

// Chinese comment replaced with English comment
export const formatCurrency = (amount: number, currency = 'CNY'): string => {
  return new Intl.NumberFormat('zh-CN', {
    style: 'currency',
    currency,
    minimumFractionDigits: 2
  }).format(amount);
};

// Chinese comment replaced with English comment
export const formatTokenAmount = (amount: number, decimals = 2): string => {
  if (amount >= 1000000) {
    return `${(amount / 1000000).toFixed(decimals)}M`;
  }
  
  if (amount >= 1000) {
    return `${(amount / 1000).toFixed(decimals)}K`;
  }
  
  return amount.toFixed(decimals);
};

// Chinese comment replaced with English comment
export const truncateString = (str: string, maxLength: number): string => {
  if (str.length <= maxLength) return str;
  return `${str.slice(0, maxLength)}...`;
};

export const truncateMiddle = (str: string, startChars = 6, endChars = 4): string => {
  if (str.length <= startChars + endChars) return str;
  return `${str.slice(0, startChars)}...${str.slice(-endChars)}`;
};

// Chinese comment replaced with English comment
export const generateId = (length = 8): string => {
  return Math.random().toString(36).substring(2, 2 + length);
};

// Chinese comment replaced with English comment
export const groupBy = <T, K extends keyof any>(
  array: T[],
  getKey: (item: T) => K
): Record<K, T[]> => {
  return array.reduce((result, item) => {
    const key = getKey(item);
    if (!result[key]) {
      result[key] = [];
    }
    result[key].push(item);
    return result;
  }, {} as Record<K, T[]>);
};

export const chunk = <T>(array: T[], size: number): T[][] => {
  const result: T[][] = [];
  for (let i = 0; i < array.length; i += size) {
    result.push(array.slice(i, i + size));
  }
  return result;
};

// Chinese comment replaced with English comment
export const deepMerge = <T1, T2>(obj1: T1, obj2: T2): T1 & T2 => {
  const merged = { ...obj1 } as any;
  
  for (const key in obj2) {
    if (obj2.hasOwnProperty(key)) {
      if (
        obj2[key] && 
        typeof obj2[key] === 'object' && 
        obj1 && 
        obj1[key] && 
        typeof obj1[key] === 'object' && 
        !Array.isArray(obj2[key]) && 
        !Array.isArray(obj1[key])
      ) {
        merged[key] = deepMerge(obj1[key], obj2[key]);
      } else {
        merged[key] = obj2[key];
      }
    }
  }
  
  return merged as T1 & T2;
};

// Chinese comment replaced with English comment
export const debounce = <T extends (...args: any[]) => any>(
  func: T,
  wait: number
): ((...args: Parameters<T>) => void) => {
  let timeout: NodeJS.Timeout | null = null;
  
  return function(...args: Parameters<T>) {
    if (timeout) clearTimeout(timeout);
    
    timeout = setTimeout(() => {
      func(...args);
    }, wait);
  };
};

// Chinese comment replaced with English comment
export const throttle = <T extends (...args: any[]) => any>(
  func: T,
  wait: number
): ((...args: Parameters<T>) => void) => {
  let lastCall = 0;
  
  return function(...args: Parameters<T>) {
    const now = Date.now();
    
    if (now - lastCall >= wait) {
      lastCall = now;
      func(...args);
    }
  };
};

// Chinese comment replaced with English comment
export const getQueryParams = (url: string): Record<string, string> => {
  const params = {};
  const queryString = url.split('?')[1];
  
  if (!queryString) return params;
  
  const pairs = queryString.split('&');
  
  for (const pair of pairs) {
    const [key, value] = pair.split('=');
    params[decodeURIComponent(key)] = decodeURIComponent(value || '');
  }
  
  return params;
};

export const buildQueryString = (params: Record<string, string | number | boolean>): string => {
  const parts = [];
  
  for (const [key, value] of Object.entries(params)) {
    if (value !== undefined && value !== null) {
      parts.push(`${encodeURIComponent(key)}=${encodeURIComponent(value.toString())}`);
    }
  }
  
  return parts.length > 0 ? `?${parts.join('&')}` : '';
};

// Chinese comment replaced with English comment
export const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
};

// Chinese comment replaced with English comment
export const toBase64 = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => resolve(reader.result as string);
    reader.onerror = (error) => reject(error);
  });
};

// Chinese comment replaced with English comment
export const hexToRgb = (hex: string): { r: number; g: number; b: number } | null => {
  const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  hex = hex.replace(shorthandRegex, (_, r, g, b) => r + r + g + g + b + b);
  
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  
  return result
    ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      }
    : null;
};

export const rgbToHex = (r: number, g: number, b: number): string => {
  return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
};

// Chinese comment replaced with English comment
export const getRandomColor = (): string => {
  return `#${Math.floor(Math.random() * 16777215).toString(16)}`;
};

// Chinese comment replaced with English comment
export const safeJsonParse = <T>(json: string, fallback: T): T => {
  try {
    return JSON.parse(json) as T;
  } catch (error) {
    return fallback;
  }
};

// Chinese comment replaced with English comment
// Chinese comment replaced with English comment
export const getExplorerUrl = (
  address: string,
  type: 'address' | 'transaction' | 'block' = 'address',
  network = 'mainnet-beta'
): string => {
  const baseUrl = 'https://explorer.solana.com';
  return `${baseUrl}/${type}/${address}?cluster=${network}`;
};

// Chinese comment replaced with English comment
export const shortenAddress = (address: string, chars = 4): string => {
  return `${address.slice(0, chars)}...${address.slice(-chars)}`;
};

export default {
  formatDate,
  formatDateTime,
  formatRelativeTime,
  formatDuration,
  formatNumber,
  formatCurrency,
  formatTokenAmount,
  truncateString,
  truncateMiddle,
  generateId,
  groupBy,
  chunk,
  deepMerge,
  debounce,
  throttle,
  getQueryParams,
  buildQueryString,
  formatFileSize,
  toBase64,
  hexToRgb,
  rgbToHex,
  getRandomColor,
  safeJsonParse,
  getExplorerUrl,
  shortenAddress
}; 